<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.533">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>review-paper</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="review-paper_files/libs/clipboard/clipboard.min.js"></script>
<script src="review-paper_files/libs/quarto-html/quarto.js"></script>
<script src="review-paper_files/libs/quarto-html/popper.min.js"></script>
<script src="review-paper_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="review-paper_files/libs/quarto-html/anchor.min.js"></script>
<link href="review-paper_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="review-paper_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="review-paper_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="review-paper_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="review-paper_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">


</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">




<p><strong>Article Category</strong>: Advanced Review</p>
<p><strong>Authors</strong>:</p>
<p>A. Cebulski<sup>1</sup> (ORCID ID - 0000-0001-7910-5056)</p>
<p>J.W. Pomeroy<sup>1</sup> (ORCID ID - 0000-0002-4782-7457)</p>
<p><sup>1</sup>Centre for Hydrology, University of Saskatchewan, Canmore, Canada</p>
<p><strong>Abstract:</strong> In needleleaf forests, up to half of annual snowfall may be ablated due to sublimation of snow intercepted in the canopy. However, limited and sparse observations of snow interception and ablation processes have hindered the development of fundamental theories underpinning current estimates of snow accumulation in forests. Existing parameterizations for snow interception and ablation have been developed in locations with distinctive climate, tree species and forest structures, resulting in differing and non-comprehensive process representations. Consequently, their transferability across diverse landscapes and climates remains uncertain. Moreover, difficulties in isolating individual processes using field-based measurements contributes further uncertainty to validation of process representations in hydrological models. Specific gaps in the literature include challenges in differentiating snow throughfall measurements from canopy snow ablation, partitioning unloading rates and canopy snowmelt drainage, the assumption of vertical falling hydrometeor trajectories, the absence of wind resuspension parameterizations, and the limited testing of parameterizations in varied forests and climates. This review article aims to elucidate the theoretical foundations and assumptions underlying the current snow interception and ablation concepts and parameterizations in the literature to inform model-decision makers in selecting parameterizations and guiding future field-based observational studies. The theory and methods behind snow interception and ablation studies are also reviewed to provide the context necessary for examining the applicability of current parameterizations across contrasting environments.</p>
<p><strong>Graphical Abstract and Caption</strong></p>
<p>Snow interception and ablation processes are essential components of hydrological models and land surface schemes. Determining how to best represent these processes in models helps inform land management, ecological conservation and water resource decisions.</p>
<p><img src="../review-paper/figs/IMG_4319_bitmap_5_mass_bal_WIRES.png" class="img-fluid"></p>
<section id="introduction" class="level2">
<h2 class="anchored" data-anchor-id="introduction">Introduction</h2>
<p>Snow interception and ablation processes and their conceptual models have never been thoroughly reviewed, though reviews of individual processes exist <span class="citation" data-cites="Pomeroy1995 Lundberg2001 VanStan2020 Lundquist2021">[@Pomeroy1995; @Lundberg2001; @VanStan2020; @Lundquist2021]</span>. To determine a path forward for the improved prediction of snow accumulation in forested environments, it is essential to conduct a comprehensive review of the underlying theory and methodologies used to develop existing parameterizations. This article will also explore processes often overlooked in existing parameterizations, including non-vertical hydrometeor trajectories, horizontal wind redistribution of snow, and rime accretion. The article further examines the limited research on snow interception and ablation in forests with diverse species and structure has impacted process understanding and restricts transferability across differing environments. Additionally, the methods used to measure or approximate these mass and energy processes are also reviewed, providing the necessary context for interpreting the underlying assumptions of existing snow interception and ablation parameterizations.</p>
</section>
<section id="sec-theory" class="level2">
<h2 class="anchored" data-anchor-id="sec-theory">The Mass and Energy Balance of Snow in the Canopy</h2>
<p>Section 2 begins with discussing the symbology used to represent mass fluxes, energy fluxes and states of snow intercepted in the canopy. This section is written in the context of a winter needleleaf forest environment.</p>
<section id="mass-balance" class="level3">
<h3 class="anchored" data-anchor-id="mass-balance">Mass Balance</h3>
<p>Section 2.1 contains a mass balance equation for canopy snow load followed by a description of each of the terms in the equation. A figure is also shown which gives a visual of the mass balance processes important for canopy snow load. Coupled mass and energy equations for the calculation of melt and sublimation of snow intercepted in the canopy are also shown.</p>
</section>
<section id="energy-balance" class="level3">
<h3 class="anchored" data-anchor-id="energy-balance">Energy Balance</h3>
<p>Section 2.2 contains an energy balance equation for snow intercepted in the canopy followed by a description of the terms. A figure showing a visual representation of the energy balance processes is shown. A discussion of some of the simplifications made with this energy balance representation is then provided.</p>
</section>
</section>
<section id="sec-methods" class="level2">
<h2 class="anchored" data-anchor-id="sec-methods">Measuring Snow Interception and Ablation</h2>
<p>Section 3 covers the common methodologies used to measure snow interception and ablation. A description of the principle behind each method is given and any uncertainties related to the method are also discussed. The methodologies described include, weighed tree, mass balance methods, snow surveys, subcanopy lysimeters and remote sensing techniques.</p>
<section id="weighed-tree" class="level3">
<h3 class="anchored" data-anchor-id="weighed-tree">Weighed Tree</h3>
</section>
<section id="mass-balance-methods" class="level3">
<h3 class="anchored" data-anchor-id="mass-balance-methods">Mass Balance Methods</h3>
<section id="sec-snow-surveys" class="level4">
<h4 class="anchored" data-anchor-id="sec-snow-surveys">Snow Surveys</h4>
</section>
<section id="subcanopy-lysimeters" class="level4">
<h4 class="anchored" data-anchor-id="subcanopy-lysimeters">Subcanopy Lysimeters</h4>
</section>
</section>
<section id="remote-sensing" class="level3">
<h3 class="anchored" data-anchor-id="remote-sensing">Remote Sensing</h3>
</section>
<section id="tree-sway-frequency" class="level3">
<h3 class="anchored" data-anchor-id="tree-sway-frequency">Tree Sway Frequency</h3>
</section>
<section id="trunk-compression" class="level3">
<h3 class="anchored" data-anchor-id="trunk-compression">Trunk Compression</h3>
</section>
</section>
<section id="sec-determination" class="level2">
<h2 class="anchored" data-anchor-id="sec-determination">Methods of Determination</h2>
<p>Section 4 discusses the parameterizations available in the literature for the determination of the mass and energy balance processes discussed in Section 2. For each parameterization a description the study environment, climate, and methodologies used to derive it is provided. Section 4.1 discusses snow interception parameterizations followed by section 4.2 which discusses snow ablation parameterizations for sublimation, unloading and drip.</p>
<section id="sec-interception" class="level3">
<h3 class="anchored" data-anchor-id="sec-interception">Snow Interception Parameterizations</h3>
<section id="hedstrom1998a" class="level4">
<h4 class="anchored" data-anchor-id="hedstrom1998a"><span class="citation" data-cites="Hedstrom1998a">@Hedstrom1998a</span></h4>
</section>
<section id="storck2002-and-andreadis2009" class="level4">
<h4 class="anchored" data-anchor-id="storck2002-and-andreadis2009"><span class="citation" data-cites="Storck2002">@Storck2002</span> and <span class="citation" data-cites="Andreadis2009">@Andreadis2009</span></h4>
</section>
<section id="katsushima2023" class="level4">
<h4 class="anchored" data-anchor-id="katsushima2023"><span class="citation" data-cites="Katsushima2023">@Katsushima2023</span></h4>
</section>
<section id="event-based-snow-interception-parameterizations" class="level4">
<h4 class="anchored" data-anchor-id="event-based-snow-interception-parameterizations">Event Based Snow Interception Parameterizations</h4>
</section>
</section>
<section id="sec-ablation" class="level3">
<h3 class="anchored" data-anchor-id="sec-ablation">Canopy Snow Ablation Parameterizations</h3>
<section id="sublimation" class="level4">
<h4 class="anchored" data-anchor-id="sublimation">Sublimation</h4>
</section>
<section id="sec-unloading" class="level4">
<h4 class="anchored" data-anchor-id="sec-unloading">Unloading and Drip</h4>
<section id="hedstrom1998a-1" class="level5">
<h5 class="anchored" data-anchor-id="hedstrom1998a-1"><span class="citation" data-cites="Hedstrom1998a">@Hedstrom1998a</span></h5>
</section>
<section id="storck2002" class="level5">
<h5 class="anchored" data-anchor-id="storck2002"><span class="citation" data-cites="Storck2002">@Storck2002</span></h5>
</section>
<section id="roesch2001" class="level5">
<h5 class="anchored" data-anchor-id="roesch2001"><span class="citation" data-cites="Roesch2001">@Roesch2001</span></h5>
</section>
<section id="bartlett2015" class="level5">
<h5 class="anchored" data-anchor-id="bartlett2015"><span class="citation" data-cites="Bartlett2015">@Bartlett2015</span></h5>
</section>
<section id="katsushima2023-1" class="level5">
<h5 class="anchored" data-anchor-id="katsushima2023-1"><span class="citation" data-cites="Katsushima2023">@Katsushima2023</span></h5>
</section>
</section>
</section>
</section>
<section id="sec-research-gaps" class="level2">
<h2 class="anchored" data-anchor-id="sec-research-gaps">Discussion</h2>
<p>In Section 5 the theories and assumptions of the parameterizations listed above are compared. Research gaps are also listed to give insight on where current snow interception and ablation parameterizations theories and assumptions may be invalid and where new observations and theoretical development is required. Advice for informing model-decision makers on choosing parameterizations is also given</p>
</section>
<section id="conclusion" class="level2">
<h2 class="anchored" data-anchor-id="conclusion">Conclusion</h2>
<p>Numerous conceptual models of snow interception and ablation have been developed, reflecting differences in the climate, canopy structure, and methodological approaches across previous studies. The choice of parameterization can significantly influence simulated outcomes, underscoring the importance of informed decision-making. However, acquiring the necessary knowledge from the literature to facilitate such decisions has proven challenging, with notable knowledge gaps persisting in process understanding. Difficulties in isolating snow interception processes in in-situ measurements may have resulted in parameterizations that are not isolated to a single process. Future work to help decouple canopy snow interception and ablation parameterizations could help minimize the over representation of certain processes and provide some clarity to model decision makers. This decoupling may have implications for canopy snow ablation parameterizations and thus should be revisited in the context of updated interception routines. Previous attempts to model snow accumulation and ablation in transitional climates had success by combining parameterizations derived from diverse climates. However, using combined parameterizations remains underutilized in contemporary models, and has the potential to better model transitional climates. Recent advances in lidar-based methods to measure subcanopy snow accumulation and canopy metrics has enhanced our understanding of how leaf contact area is influenced by snowfall trajectory angle and canopy snow load. However, further work is required to integrate these novel results into snow interception parameterizations. Parameterizations that ablate snow intercepted in the canopy differ in the level of detail in canopy snowmelt models and number of processes included snow such as wind induced unloading and resuspension, rime-ice accretion, and time-based unloading. Future work is required to determine the appropriate level of detail in canopy snowmelt models and the whether the relationships used in existing ablation parameterizations hold for other locations.</p>
<p>A comprehensive field-based investigation into canopy snow interception and ablation processes is needed to address these remaining research gaps. Utilizing observations of forest snow accumulation and canopy snow ablation across diverse forests and climates is crucial for assessing and refining existing theories of snow interception and ablation processes. This approach will enhance our understanding of where existing parameterizations fail, what processes drive model uncertainty, and how parameterizations can be modified to better represent forest snow accumulation.</p>
</section>
<section id="funding-information" class="level2">
<h2 class="anchored" data-anchor-id="funding-information">Funding Information</h2>
<p>Dean’s Scholarship – University of Saskatchewan Devolved Scholarship – University of Saskatchewan Discovery Grant – National Sciences and Engineering Research Council of Canada Global Water Futures Programme – Canada First Research Excellence Fund Canada Research Chairs Programme – Government of Canada Water Information Program Grant, Alberta Innovates</p>
</section>
<section id="acknowledgments" class="level2">
<h2 class="anchored" data-anchor-id="acknowledgments">Acknowledgments</h2>
<p>We wish to acknowledge financial support from the University of Saskatchewan, Natural Sciences and Engineering Research Council of Canada, Global Water Futures Programme, Alberta Innovates and the Canada Research Chairs Programme. We thank Martyn Clark for his advice in outlining the steps to derive analytical solutions from the ordinary difference equation representation of the parameterizations.</p>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      return note.innerHTML;
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>